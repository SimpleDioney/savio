<!DOCTYPE html>
<html lang="pt-BR">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Sistema de Gerenciamento de Tarefas</title>
    <style>
      :root {
        --bg-primary: #1a1a1a;
        --bg-secondary: #2d2d2d;
        --text-primary: #ffffff;
        --text-secondary: #b3b3b3;
        --accent: #007bff;
        --success: #28a745;
        --danger: #dc3545;
        --warning: #ffc107;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
        font-family: "Segoe UI", sans-serif;
      }

      body {
        background-color: var(--bg-primary);
        color: var(--text-primary);
        line-height: 1.6;
        min-height: 100vh;
      }

      .greeting {
        font-size: 1.2em;
        font-weight: bold;
        color: #333;
        margin-right: 20px;
      }

      .admin-only {
        display: none;
      }

      .date-input,
      .status-select {
        padding: 8px;
        border: 1px solid #ddd;
        border-radius: 4px;
        margin-left: 10px;
      }

      .header {
        background-color: var(--bg-secondary);
        padding: 1rem 2rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        position: sticky;
        top: 0;
        z-index: 1000;
      }

      .header-title {
        font-size: 1.5rem;
        font-weight: 600;
      }

      .header-controls {
        display: flex;
        align-items: center;
        gap: 1rem;
      }

      .datetime {
        text-align: right;
        font-size: 0.9rem;
      }

      .main-container {
        max-width: 1400px;
        margin: 0 auto;
        padding: 2rem;
      }

      .btn {
        background-color: var(--accent);
        color: white;
        border: none;
        padding: 0.5rem 1rem;
        border-radius: 4px;
        cursor: pointer;
        font-size: 0.9rem;
        transition: opacity 0.2s ease;
        display: inline-flex;
        align-items: center;
        gap: 0.5rem;
      }

      .btn:hover {
        opacity: 0.9;
      }

      .btn-success {
        background-color: var(--success);
      }
      .btn-danger {
        background-color: var(--danger);
      }
      .btn-warning {
        background-color: var(--warning);
        color: var(--bg-primary);
      }

      .filters {
        background: var(--bg-secondary);
        padding: 1.5rem;
        border-radius: 8px;
        margin-bottom: 2rem;
        display: flex;
        gap: 1.5rem;
        flex-wrap: wrap;
        align-items: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .filter-group {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .filter-group label {
        font-size: 0.9rem;
        color: var(--text-secondary);
      }

      .filter-group input,
      .filter-group select {
        background: var(--bg-primary);
        border: 1px solid var(--bg-secondary);
        color: var(--text-primary);
        padding: 0.5rem;
        border-radius: 4px;
        font-size: 0.9rem;
      }

      .filter-group input:focus,
      .filter-group select:focus {
        outline: none;
        border-color: var(--accent);
      }

      .statistics {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 1.5rem;
        margin-bottom: 2rem;
      }

      .stat-card {
        background: var(--bg-secondary);
        padding: 1.5rem;
        border-radius: 8px;
        text-align: center;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
        transition: transform 0.2s ease;
      }

      .stat-card:hover {
        transform: translateY(-2px);
      }

      .stat-value {
        font-size: 2rem;
        font-weight: bold;
        margin: 0.5rem 0;
        color: var(--accent);
      }

      .task-grid {
        display: grid;
        grid-template-columns: repeat(auto-fill, minmax(350px, 1fr));
        gap: 1.5rem;
        margin-top: 2rem;
      }

      .employee-card {
        background: var(--bg-secondary);
        border-radius: 8px;
        position: relative;
        overflow: hidden;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.1);
      }

      .employee-header {
        padding: 1.5rem;
        background: rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .employee-name {
        font-size: 1.2rem;
        font-weight: 600;
      }

      .employee-status {
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.9em;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .status-working {
        background: var(--success);
        color: white;
      }

      .status-off {
        background: var(--danger);
        color: white;
      }

      .status-leave {
        background: var(--warning);
        color: var(--bg-primary);
      }

      .work-schedule {
        color: var(--text-secondary);
        font-size: 0.9em;
        margin-top: 4px;
        display: flex;
        align-items: center;
        gap: 6px;
      }

      .employee-status-container {
        display: flex;
        align-items: center;
        gap: 8px;
      }

      .tasks-container {
        padding: 1.5rem;
        max-height: 500px;
        overflow-y: auto;
      }

      .task-item {
        background: var(--bg-primary);
        padding: 1rem;
        border-radius: 6px;
        margin-bottom: 1rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
        transition: transform 0.2s ease;
      }

      .task-item:hover {
        transform: translateX(4px);
      }

      .task-item.fixed {
        border-left: 3px solid var(--accent);
      }

      .task-info {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .task-priority {
        width: 10px;
        height: 10px;
        border-radius: 50%;
        flex-shrink: 0;
      }

      .priority-1 {
        background: var(--warning);
      }
      .priority-2 {
        background: var(--accent);
      }
      .priority-3 {
        background: var(--danger);
      }

      .task-controls {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }

      .task-status {
        padding: 0.25rem 0.75rem;
        border-radius: 4px;
        font-size: 0.8rem;
        border: none;
        background: var(--bg-secondary);
        color: var(--text-primary);
        cursor: pointer;
      }

      .status-pendente {
        background: var(--warning);
        color: var(--bg-primary);
      }
      .status-em_andamento {
        background: var(--accent);
      }
      .status-concluido {
        background: var(--success);
      }

      .modal {
        display: none;
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
        background: rgba(0, 0, 0, 0.8);
        z-index: 1000;
        overflow: auto;
      }

      .modal-content {
        background: var(--bg-secondary);
        margin: 10% auto;
        padding: 2rem;
        border-radius: 8px;
        max-width: 500px;
        position: relative;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
      }

      .modal-header {
        margin-bottom: 1.5rem;
      }

      .form-group {
        margin-bottom: 1.5rem;
      }

      .form-group label {
        display: block;
        margin-bottom: 0.5rem;
        color: var(--text-secondary);
      }

      .form-group input,
      .form-group select,
      .form-group textarea {
        width: 100%;
        padding: 0.75rem;
        background: var(--bg-primary);
        border: 1px solid var(--bg-secondary);
        color: var(--text-primary);
        border-radius: 4px;
        font-size: 1rem;
      }

      .form-group input:focus,
      .form-group select:focus,
      .form-group textarea:focus {
        outline: none;
        border-color: var(--accent);
      }

      .checkbox-group {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        cursor: pointer;
      }

      .modal-footer {
        display: flex;
        justify-content: flex-end;
        gap: 1rem;
        margin-top: 2rem;
      }

      /* Scrollbar personalizada */
      ::-webkit-scrollbar {
        width: 8px;
      }

      ::-webkit-scrollbar-track {
        background: var(--bg-primary);
      }

      ::-webkit-scrollbar-thumb {
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      ::-webkit-scrollbar-thumb:hover {
        background: var(--accent);
      }

      .header-content {
        display: flex;
        align-items: center;
        gap: 2rem;
      }

      .greeting {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        color: var(--text-primary);
        font-size: 0.9rem;
      }

      .greeting-icon {
        font-size: 1.2rem;
      }

      @media (max-width: 768px) {
        .header-content {
          flex-direction: column;
          gap: 1rem;
        }
      }

      /* Responsividade */
      @media (max-width: 768px) {
        .main-container {
          padding: 1rem;
        }

        .header {
          padding: 1rem;
          flex-direction: column;
          text-align: center;
          gap: 1rem;
        }

        .filters {
          flex-direction: column;
          align-items: stretch;
        }

        .filter-group {
          flex-direction: column;
          align-items: stretch;
        }

        .task-grid {
          grid-template-columns: 1fr;
        }

        .modal-content {
          margin: 5% 1rem;
        }
      }
      .main-user-container {
        transition: all 0.3s ease;
      }

      .main-user-container:hover {
        transform: translateY(-2px);
      }

      .store-badge {
        background: var(--bg-primary);
        color: var(--text-primary);
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-left: 8px;
        border: 1px solid var(--text-secondary);
      }

      .current-user-badge {
        background: var(--accent);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
        margin-left: 8px;
      }

      .employee-name {
        display: flex;
        align-items: center;
        flex-wrap: wrap;
        gap: 4px;
        font-size: 1.2rem;
        font-weight: bold;
      }

      .employee-card {
        background: var(--bg-secondary);
        border-radius: 8px;
        margin-bottom: 1rem;
        overflow: hidden;
      }

      .employee-card.current-user {
        background: linear-gradient(
          to right,
          var(--bg-secondary),
          var(--bg-secondary)
        );
      }

      .employee-header {
        padding: 1rem;
        background: rgba(0, 0, 0, 0.2);
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .employee-task-count {
        font-size: 0.9em;
        color: var(--text-secondary);
      }

      .tasks-container {
        padding: 1rem;
      }

      .task-item {
        background: var(--bg-primary);
        padding: 1rem;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        display: flex;
        justify-content: space-between;
        align-items: center;
      }

      .task-item:last-child {
        margin-bottom: 0;
      }

      .employee-status {
        padding: 4px 12px;
        border-radius: 12px;
        font-size: 0.9em;
      }

      .status-available {
        background: var(--success);
        color: white;
      }

      .status-leave {
        background: var(--warning);
        color: var(--bg-primary);
      }

      .task-controls select:disabled {
        opacity: 0.7;
        cursor: not-allowed;
      }

      .store-badge {
        background: var(--accent);
        color: white;
        padding: 2px 8px;
        border-radius: 12px;
        font-size: 0.8em;
      }

      .task-item {
        background: var(--bg-primary);
        padding: 0.75rem 1rem;
        border-radius: 4px;
        margin-bottom: 0.5rem;
        display: flex;
        justify-content: space-between;
        align-items: flex-start; /* Mudado para flex-start para alinhar no topo */
      }

      .task-info {
        display: flex;
        gap: 0.75rem;
        flex: 1;
      }

      .task-name {
        word-break: break-word; /* Força a quebra de palavra */
        white-space: pre-line; /* Mantém as quebras de linha do texto */
        line-height: 1.4;
        flex: 1;
      }

      .task-controls {
        flex-shrink: 0;
        margin-left: 1rem;
      }

      .notification {
        position: fixed;
        top: 1rem;
        right: 1rem;
        padding: 1rem 1.5rem;
        border-radius: 6px;
        color: var(--text-primary);
        box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
        display: none;
        animation: slideIn 0.3s ease;
        z-index: 1000;
        font-size: 0.95rem;
        max-width: 350px;
        word-wrap: break-word;
      }

      .notification.info {
        background-color: var(--accent);
      }

      .notification.success {
        background-color: var(--success);
      }

      .notification.error {
        background-color: var(--danger);
      }

      .notification.warning {
        background-color: var(--warning);
        color: var(--bg-primary);
      }

      @keyframes slideIn {
        from {
          transform: translateX(100%);
          opacity: 0;
        }
        to {
          transform: translateX(0);
          opacity: 1;
        }
      }

      @keyframes slideOut {
        from {
          transform: translateX(0);
          opacity: 1;
        }
        to {
          transform: translateX(100%);
          opacity: 0;
        }
      }

      @media (max-width: 480px) {
        .notification {
          left: 1rem;
          right: 1rem;
          text-align: center;
        }
      }

      .calendar-day.weekend {
        background: var(--bg-primary);
      }

      .calendar-day.selected {
        background: var(--success);
        color: white;
      }


      .selected-dates {
        margin: 1rem 0;
        padding: 1rem;
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      .tabs {
        display: flex;
        margin-bottom: 1rem;
        border-bottom: 1px solid var(--bg-secondary);
      }

      .tab-button {
        padding: 0.5rem 1rem;
        background: none;
        border: none;
        color: var(--text-primary);
        cursor: pointer;
        border-bottom: 2px solid transparent;
      }

      .tab-button.active {
        border-bottom-color: var(--accent);
      }

      .tab-content {
        display: none;
      }

      .tab-content.active {
        display: block;
      }

      .calendar-header {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        text-align: center;
        margin-bottom: 10px;
        font-weight: bold;
      }

      .calendar-header div {
        padding: 10px;
        background: var(--bg-secondary);
        border-radius: 4px;
      }

      .calendar {
        display: grid;
        grid-template-columns: repeat(7, 1fr);
        gap: 5px;
      }

      .calendar-day {
        background: var(--bg-secondary);
        padding: 10px;
        text-align: center;
        border-radius: 4px;
        position: relative;
        min-height: 40px;
        display: flex;
        align-items: center;
        justify-content: center;
        cursor: pointer;
      }

      .calendar-day.empty {
        background: transparent;
      }

      .calendar-day.has-leave {
        background: var(--accent) !important;
        color: white !important;
      }

      .calendar-day .leave-count {
        position: absolute;
        top: 2px;
        right: 2px;
        font-size: 0.8em;
      }

      .leave-details {
        display: none;
        position: absolute;
        top: 100%;
        left: 50%;
        transform: translateX(-50%);
        background: var(--bg-secondary);
        padding: 8px;
        border-radius: 4px;
        box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2);
        z-index: 1000;
        min-width: 150px;
        white-space: nowrap;
      }

      .calendar-day:hover .leave-count {
        opacity: 0.8;
      }

      .calendar-day.weekend:not(.unavailable) {
        cursor: pointer;
        background: var(--bg-primary);
        transition: background-color 0.2s;
      }

      .calendar-day.weekend:not(.unavailable):hover {
        background: var(--accent);
        opacity: 0.7;
      }

      .calendar-day.selected {
        background: var(--success) !important;
        color: white;
      }

      .calendar-day.weekend {
        background: var(--bg-primary);
        font-weight: bold;
        border: 1px solid var(--accent);
      }

      .calendar-day.weekend:not(.unavailable):hover {
        background: var(--accent);
        opacity: 0.8;
        color: white;
      }

      .calendar-day:not(.weekend) {
        opacity: 0.5;
        background: var(--bg-secondary);
      }

      .calendar-day.unavailable {
  opacity: 0.6;
  text-decoration: line-through;
  cursor: not-allowed;
  background-color: #f5f5f5;
  color: #999;
}

/* Garantir que o line-through tenha maior especificidade */
.calendar .calendar-day.unavailable {
  text-decoration: line-through !important;
}

      .calendar-day.selected {
        background: var(--success);
        color: white;
        border-color: var(--success);
      }


      .leave-details {
    position: absolute;
    top: 100%;
    left: 50%;
    transform: translateX(-50%);
    background: var(--bg-secondary);
    padding: 8px;
    border-radius: 4px;
    box-shadow: 0 2px 4px rgba(0,0,0,0.2);
    z-index: 1000;
    min-width: 150px;
    display: none;
    white-space: nowrap;
}

.calendar-day.has-leave {
    cursor: pointer;
    position: relative;
}

.calendar-day.has-leave:hover .leave-details {
    display: block;
}

.leave-item {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 4px 0;
    border-bottom: 1px solid var(--bg-primary);
}

.leave-item:last-child {
    border-bottom: none;
}

.alternative-badge {
    background: var(--accent);
    color: white;
    padding: 2px 8px;
    border-radius: 12px;
    font-size: 0.8em;
    margin-left: 8px;
    display: inline-flex;
    align-items: center;
    gap: 4px;
}

.work-schedule {
    display: flex;
    align-items: center;
    flex-wrap: wrap;
    gap: 8px;
    margin-top: 4px;
}
    </style>
  </head>
  <body>
    <header class="header">
      <div class="header-content">
        <div class="header-title">Sistema de Gerenciamento de Tarefas</div>
        <div id="userGreeting" class="greeting"></div>
      </div>
      <div class="header-controls">
        <div class="datetime">
          <div id="date"></div>
          <div id="clock"></div>
        </div>
        <button class="btn" onclick="showLeavesModal()">Minhas Folgas</button>
        <a href="/admin.html" class="btn">Administração</a>
        <button class="btn btn-danger" onclick="logout()">Sair</button>
      </div>
    </header>

    <div class="main-container">
      <div class="filters">
        <div class="filter-group">
          <label for="filterDate">Data:</label>
          <input type="date" id="filterDate" />
        </div>
        <div class="filter-group">
          <label for="filterStatus">Status:</label>
          <select id="filterStatus">
            <option value="">Todos</option>
            <option value="pendente">Pendente</option>
            <option value="em_andamento">Em Andamento</option>
            <option value="concluido">Concluído</option>
          </select>
        </div>
        <div class="filter-group">
          <label for="filterStore">Loja:</label>
          <select id="filterStore">
            <option value="">Todas as Lojas</option>
          </select>
        </div>
        <div class="filter-group">
          <button
            class="btn btn-success"
            onclick="distributeTasksAutomatically()"
          >
            Distribuir Tarefas
          </button>
          <button class="btn" onclick="showAddTaskModal()">Nova Tarefa</button>
        </div>
      </div>

      <div id="leavesModal" class="modal">
        <div class="modal-content">
          <div class="modal-header">
            <h2>Minhas Folgas</h2>
          </div>

          <div class="tabs">
            <button class="tab-button active" data-tab="view-leaves">
              Visualizar Folgas
            </button>
            <button class="tab-button" data-tab="request-leave">
              Solicitar Folga
            </button>
          </div>

          <div id="view-leaves" class="tab-content active">
            <div class="form-group">
              <label for="leaveMonth">Mês</label>
              <input type="month" id="leaveMonth" value="" />
            </div>

            <div id="leavesCalendar">
              <div class="calendar-header"></div>
              <div class="calendar"></div>
            </div>
          </div>

          <div id="request-leave" class="tab-content">
            <div class="form-group">
              <label for="requestMonth">Mês da Solicitação</label>
              <input type="month" id="requestMonth" value="" />
            </div>

            <div id="requestCalendar">
              <div class="calendar-header"></div>
              <div class="calendar"></div>
            </div>

            <div class="selected-dates">
              <p>Selecione um sábado e um domingo consecutivos</p>
              <div id="selectedDates"></div>
            </div>

            <button id="submitRequest" class="btn btn-success" disabled>
              Enviar Solicitação
            </button>
          </div>

          <div class="modal-footer">
            <button class="btn btn-danger" onclick="closeLeavesModal()">
              Fechar
            </button>
          </div>
        </div>
      </div>
      <div class="statistics">
        <div class="stat-card">
          <h3>Total de Tarefas</h3>
          <div id="totalTasks" class="stat-value">0</div>
          <div class="stat-label">tarefas hoje</div>
        </div>
        <div class="stat-card">
          <h3>Tarefas Concluídas</h3>
          <div id="completedTasks" class="stat-value">0</div>
          <div class="stat-label">finalizadas</div>
        </div>
        <div class="stat-card">
          <h3>Funcionários Ativos</h3>
          <div id="activeEmployees" class="stat-value">0</div>
          <div class="stat-label">disponíveis hoje</div>
        </div>
      </div>

      <div id="taskGrid" class="task-grid">
        <!-- Preenchido via JavaScript -->
      </div>
    </div>

    <!-- Modal de Nova Tarefa -->
    <div id="taskModal" class="modal">
      <div class="modal-content">
        <div class="modal-header">
          <h2>Nova Tarefa</h2>
        </div>
        <div class="form-group">
          <label for="taskName">Nome da Tarefa</label>
          <input
            type="text"
            id="taskName"
            placeholder="Digite o nome da tarefa"
          />
        </div>
        <div class="form-group">
          <label for="taskDescription">Descrição (opcional)</label>
          <textarea
            id="taskDescription"
            rows="3"
            placeholder="Digite uma descrição para a tarefa"
          ></textarea>
        </div>
        <div class="form-group">
          <label for="taskPriority">Prioridade</label>
          <select id="taskPriority">
            <option value="1">Baixa</option>
            <option value="2">Média</option>
            <option value="3">Alta</option>
          </select>
        </div>
        <div class="form-group">
          <label for="assignedTo">Atribuir para</label>
          <select id="assignedTo">
            <option value="">Distribuição Automática</option>
          </select>
        </div>
        <div class="form-group">
          <label class="checkbox-group">
            <input type="checkbox" id="isFixed" />
            Tarefa Fixa (será atribuída sempre ao mesmo funcionário)
          </label>
        </div>
        <div class="modal-footer">
          <button class="btn btn-danger" onclick="closeTaskModal()">
            Cancelar
          </button>
          <button class="btn btn-success" onclick="saveTask()">Salvar</button>
        </div>
      </div>
    </div>

    <script>
      // Estado global
      let currentUser = null;
      let employees = [];
      let tasks = [];
      let stores = [];
      let currentDate = new Date();
      let selectedDate = new Date().toISOString().split("T")[0];
      let selectedDates = [];
      let existingRequests = [];

      // Funções de utilidade
      function updateDateTime() {
        const now = new Date();
        document.getElementById("date").textContent =
          now.toLocaleDateString("pt-BR");
        document.getElementById("clock").textContent =
          now.toLocaleTimeString("pt-BR");
      }

      // Configurar tabs do modal de folgas
      function setupLeavesModalTabs() {
    document.querySelectorAll('#leavesModal .tab-button').forEach(button => {
        button.addEventListener('click', async (e) => {
            // Remover classe active de todas as tabs
            document.querySelectorAll('#leavesModal .tab-button').forEach(b => 
                b.classList.remove('active'));
            document.querySelectorAll('#leavesModal .tab-content').forEach(c => 
                c.classList.remove('active'));

            // Adicionar classe active na tab clicada
            button.classList.add('active');
            
            // Mostrar conteúdo correspondente
            const tabId = button.getAttribute('data-tab');
            const content = document.getElementById(tabId);
            if (content) {
                content.classList.add('active');
            }

            // Se for a tab de solicitação, atualizar calendário
            if (tabId === 'request-leave') {
                const currentMonth = document.getElementById('requestMonth').value;
                await loadExistingRequests(currentMonth);
                updateRequestCalendar();
            }
        });
    });

        // Configurar evento de mudança de mês na solicitação

        document.getElementById('leaveMonth').addEventListener('change', updateLeavesCalendar);
    document.getElementById('requestMonth').addEventListener('change', async (e) => {
        await loadExistingRequests(e.target.value);
        updateRequestCalendar();
    });

        // Configurar botão de enviar solicitação
        document
          .getElementById("submitRequest")
          .addEventListener("click", submitLeaveRequest);
      }

      // Atualizar a função showLeavesModal para incluir a configuração das tabs
      function showLeavesModal() {
    const modal = document.getElementById('leavesModal');
    modal.style.display = 'block';
    
    // Definir mês atual
    const now = new Date();
    const currentMonth = now.toISOString().slice(0, 7);
    document.getElementById('leaveMonth').value = currentMonth;
    document.getElementById('requestMonth').value = currentMonth;
    
    // Carregar dados iniciais em sequência
    updateLeavesCalendar().then(() => {
        loadExistingRequests(currentMonth)
            .then(() => updateRequestCalendar());
    });

        // Configurar tabs se ainda não estiverem configuradas
        if (!modal.dataset.tabsConfigured) {
        setupLeavesModalTabs();
        modal.dataset.tabsConfigured = 'true';
    }
}


      function closeLeavesModal() {
        const modal = document.getElementById("leavesModal");
        modal.style.display = "none";
      }

      async function updateLeavesCalendar() {
    try {
        const month = document.getElementById('leaveMonth').value;
        const [year, monthNum] = month.split('-');
        
        // Buscar folgas do usuário
        const response = await fetch(
            `/api/employees/${currentUser.employeeId}/leaves?month=${monthNum}&year=${year}`,
            {
                headers: {
                    'Authorization': `Bearer ${localStorage.getItem('token')}`
                }
            }
        );

        if (!response.ok) throw new Error('Erro ao carregar folgas');
        const leaves = await response.json();

        // Montar cabeçalho do calendário
        const weekDays = ['Dom', 'Seg', 'Ter', 'Qua', 'Qui', 'Sex', 'Sáb'];
        const headerHtml = weekDays.map(day => `<div>${day}</div>`).join('');
        const calendarHeader = document.querySelector('#leavesCalendar .calendar-header');
        if (calendarHeader) {
            calendarHeader.innerHTML = headerHtml;
        }

        const calendar = document.querySelector('#leavesCalendar .calendar');
        if (!calendar) return;

        const daysInMonth = new Date(year, monthNum, 0).getDate();
        const firstDay = new Date(year, monthNum - 1, 1).getDay();

        let calendarHtml = '';

        // Adicionar dias vazios no início
        for (let i = 0; i < firstDay; i++) {
            calendarHtml += '<div class="calendar-day empty"></div>';
        }

        // Adicionar dias do mês
        for (let day = 1; day <= daysInMonth; day++) {
            const date = `${year}-${monthNum.padStart(2, '0')}-${String(day).padStart(2, '0')}`;
            const hasLeave = leaves.some(leave => leave.date === date);

            calendarHtml += `
                <div class="calendar-day ${hasLeave ? 'has-leave' : ''}">
                    ${day}
                    ${hasLeave ? '<div class="leave-count">✓</div>' : ''}
                </div>
            `;
        }

        calendar.innerHTML = calendarHtml;
    } catch (error) {
        console.error('Erro ao atualizar calendário:', error);
        showNotification('Erro ao atualizar calendário', 'error');
    }
}

      // Event Listeners
      document
        .getElementById("leaveMonth")
        .addEventListener("change", updateLeavesCalendar);

      // Fechar modal ao clicar fora
      window.addEventListener("click", (e) => {
        const modal = document.getElementById("leavesModal");
        if (e.target === modal) {
          closeLeavesModal();
        }
      });


      function updateRequestCalendar() {
        const month = document.getElementById("requestMonth").value;
        const [year, monthNum] = month.split("-");
        const calendar = document.querySelector("#requestCalendar .calendar");
        calendar.innerHTML = "";

        // Limpar seleções anteriores se não houver nenhuma seleção válida
        if (selectedDates.length !== 2) {
          selectedDates = [];
          updateSelectedDatesDisplay();
        }

        // Criar cabeçalho do calendário
        const weekDays = ["Dom", "Seg", "Ter", "Qua", "Qui", "Sex", "Sáb"];
        const calendarHeader = document.querySelector(
          "#requestCalendar .calendar-header"
        );
        calendarHeader.innerHTML = weekDays
          .map((day) => `<div>${day}</div>`)
          .join("");

        // Criar data do primeiro dia do mês
        const firstDate = new Date(parseInt(year), parseInt(monthNum) - 1, 1);
        const firstDay = firstDate.getDay(); // 0 = Domingo, 6 = Sábado
        const daysInMonth = new Date(
          parseInt(year),
          parseInt(monthNum),
          0
        ).getDate();

        // Adicionar dias vazios até o primeiro dia do mês
        for (let i = 0; i < firstDay; i++) {
          const emptyDay = document.createElement("div");
          emptyDay.className = "calendar-day empty";
          calendar.appendChild(emptyDay);
        }

        // Adicionar todos os dias do mês
        for (let day = 1; day <= daysInMonth; day++) {
          const currentDate = new Date(
            parseInt(year),
            parseInt(monthNum) - 1,
            day
          );
          const dateString = currentDate.toISOString().split("T")[0];
          const dayOfWeek = currentDate.getDay();

          const isSaturday = dayOfWeek === 6;
          const isSunday = dayOfWeek === 0;
          const isWeekend = isSaturday || isSunday;
          const isUnavailable = existingRequests.some(
            (req) => req.date === dateString
          );
          const isSelected = selectedDates.includes(dateString);

          const dayElement = document.createElement("div");
          dayElement.className = "calendar-day";

          if (isWeekend) dayElement.classList.add("weekend");
          if (isUnavailable) dayElement.classList.add("unavailable");
          if (isSelected) dayElement.classList.add("selected");

          // Adicionar indicador de Sáb/Dom
          dayElement.textContent = `${day}${
            isSaturday ? " (Sáb)" : isSunday ? " (Dom)" : ""
          }`;
          dayElement.dataset.date = dateString;
          dayElement.dataset.dayOfWeek = dayOfWeek;

          // Adicionar evento de clique apenas para fins de semana não indisponíveis
          if (isWeekend && !isUnavailable) {
            dayElement.addEventListener("click", () => selectDate(dayElement));
            dayElement.style.cursor = "pointer";
          }

          calendar.appendChild(dayElement);
        }
      }

      function selectDate(element) {
        const date = element.dataset.date;
        const dayOfWeek = parseInt(element.dataset.dayOfWeek);

        // Se já está selecionado, remove a seleção
        if (selectedDates.includes(date)) {
          selectedDates = selectedDates.filter((d) => d !== date);
          element.classList.remove("selected");
          updateSelectedDatesDisplay();
          return;
        }

        // Se nenhuma data selecionada ainda, deve ser um sábado
        if (selectedDates.length === 0) {
          if (dayOfWeek !== 6) {
            showNotification("Selecione primeiro um sábado", "warning");
            return;
          }
          selectedDates.push(date);
          element.classList.add("selected");
        }
        // Se já tem uma data selecionada, deve ser um domingo consecutivo
        else if (selectedDates.length === 1) {
          if (dayOfWeek !== 0) {
            showNotification("Selecione um domingo", "warning");
            return;
          }

          const saturdayDate = new Date(selectedDates[0]);
          const sundayDate = new Date(date);
          const diffTime = Math.abs(sundayDate - saturdayDate);
          const diffDays = Math.ceil(diffTime / (1000 * 60 * 60 * 24));

          if (diffDays !== 1) {
            showNotification(
              "Selecione o domingo consecutivo ao sábado",
              "warning"
            );
            return;
          }

          selectedDates.push(date);
          element.classList.add("selected");
        }

        updateSelectedDatesDisplay();
      }

      function updateSelectedDatesDisplay() {
        const display = document.getElementById("selectedDates");
        const submitButton = document.getElementById("submitRequest");

        if (selectedDates.length === 0) {
          display.innerHTML = "Nenhuma data selecionada";
          submitButton.disabled = true;
        } else {
          const dates = selectedDates.map((date) => {
            const [year, month, day] = date.split("-");
            const d = new Date(year, month - 1, day); // Sem ajuste UTC
            return d.toLocaleDateString("pt-BR", {
              weekday: "long",
              day: "numeric",
              month: "long",
            });
          });

          display.innerHTML = dates.join("<br>");
          submitButton.disabled = selectedDates.length !== 2;
        }
      }

      async function submitLeaveRequest() {
    try {
        const response = await fetch('/api/leave-requests', {
            method: 'POST',
            headers: {
                'Content-Type': 'application/json',
                'Authorization': `Bearer ${localStorage.getItem('token')}`
            },
            body: JSON.stringify({ 
                dates: selectedDates,
                status: 'pending'  // Adicionando status explicitamente
            })
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message);
        }
        
        showNotification('Solicitação enviada com sucesso', 'success');
        selectedDates = [];
        updateRequestCalendar();
        await loadExistingRequests(); // Recarregar solicitações após enviar
    } catch (error) {
        console.error('Erro:', error);
        showNotification(error.message, 'error');
    }
}

async function loadExistingRequests(month) {
    try {
        if (!month) {
            month = new Date().toISOString().slice(0, 7);
        }

        const response = await fetch(`/api/leave-requests?month=${month}`, {
            headers: {
                'Authorization': `Bearer ${localStorage.getItem('token')}`
            }
        });
        
        if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || 'Erro ao carregar solicitações');
        }
        
        const requests = await response.json();
        
        // Mapear as datas das solicitações para verificar disponibilidade
        existingRequests = [];
        requests.forEach(request => {
            request.dates.forEach(date => {
                existingRequests.push({
                    date: date,
                    employeeId: request.employeeId,
                    status: request.status
                });
            });
        });

        return existingRequests;
    } catch (error) {
        console.error('Erro:', error);
        showNotification('Erro ao carregar solicitações existentes', 'error');
        return [];
    }
}

      // Atualizar relógio a cada segundo
      setInterval(updateDateTime, 1000);
      updateDateTime();

      // Funções de autenticação
      function logout() {
        localStorage.removeItem("token");
        window.location.href = "/login.html";
      }

      // Função para carregar lojas
      async function loadStores() {
        try {
          const response = await fetch("/api/stores", {
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) throw new Error("Erro ao carregar lojas");

          stores = await response.json();
          updateStoreSelects();
        } catch (error) {
          console.error("Erro ao carregar lojas:", error);
          showNotification("Erro ao carregar lojas", "error");
        }
      }

      // Função para atualizar selects de loja
      function updateStoreSelects() {
        const filterStore = document.getElementById("filterStore");
        const taskStore = document.getElementById("taskStore");

        const storeOptions = stores
          .filter((store) => store.active)
          .map((store) => `<option value="${store.id}">${store.name}</option>`)
          .join("");

        if (filterStore) {
          filterStore.innerHTML =
            '<option value="">Todas as Lojas</option>' + storeOptions;
        }
        if (taskStore) {
          taskStore.innerHTML =
            '<option value="">Selecione uma Loja</option>' + storeOptions;
        }
      }

      // Funções do modal
      function showAddTaskModal() {
        const modal = document.getElementById("taskModal");
        const modalContent = modal.querySelector(".modal-content");

        // Atualizar o HTML do modal para incluir seleção de loja para admin
        if (currentUser.isAdmin) {
          // Verificar se o elemento de loja já existe para evitar duplicação
          if (!modalContent.querySelector("#taskStore")) {
            const storeSelect = document.createElement("div");
            storeSelect.className = "form-group";
            storeSelect.innerHTML = `
                <label for="taskStore">Loja *</label>
                <select id="taskStore" required>
                    <option value="">Selecione uma loja</option>
                    ${stores
                      .filter((store) => store.active)
                      .map(
                        (store) => `
                            <option value="${store.id}">${store.name}</option>
                        `
                      )
                      .join("")}
                </select>
            `;

            // Inserir o select de loja após o título do modal
            const modalHeader = modalContent.querySelector(".modal-header");
            modalHeader.insertAdjacentElement("afterend", storeSelect);

            // Adicionar evento para atualizar funcionários quando a loja for selecionada
            document
              .getElementById("taskStore")
              .addEventListener("change", updateEmployeeSelect);
          }
        }

        modal.style.display = "block";

        // Limpar campos
        document.getElementById("taskName").value = "";
        document.getElementById("taskDescription").value = "";
        document.getElementById("taskPriority").value = "1";
        if (currentUser.isAdmin) {
          document.getElementById("taskStore").value = "";
        }
        document.getElementById("assignedTo").innerHTML =
          '<option value="">Distribuição Automática</option>';
        document.getElementById("isFixed").checked = false;

        document.getElementById("taskName").focus();
      }

      function updateGreeting() {
        const hour = new Date().getHours();
        let greeting = "";
        let icon = "";

        if (hour >= 5 && hour < 12) {
          greeting = "Bom dia";
          icon = "🌅";
        } else if (hour >= 12 && hour < 18) {
          greeting = "Boa tarde";
          icon = "☀️";
        } else {
          greeting = "Boa noite";
          icon = "🌙";
        }

        const greetingElement = document.getElementById("userGreeting");
        const token = localStorage.getItem("token");

        if (greetingElement && token) {
          try {
            const userData = JSON.parse(atob(token.split(".")[1]));
            const userName = userData.employeeName || userData.username;
            greetingElement.innerHTML = `${icon} Olá, ${userName}! ${greeting}!`;
          } catch (error) {
            console.error("Erro ao decodificar token:", error);
            greetingElement.innerHTML = `${icon} ${greeting}!`;
          }
        }
      }

      function configureInitialInterface() {
        const currentEmployee = employees.find(
          (emp) => emp.id === currentUser.employeeId
        );

        if (currentEmployee?.store_id) {
          const filterStore = document.getElementById("filterStore");
          if (filterStore) {
            filterStore.value = currentEmployee.store_id;

            // Se não for admin, desabilitar a troca de loja
            if (!currentUser.isAdmin) {
              filterStore.disabled = true;
            }

            // Disparar evento de change para atualizar a visualização
            filterStore.dispatchEvent(new Event("change"));
          }
        }
      }

      // Inicialização
      async function init() {
        const token = localStorage.getItem("token");
        if (!token) {
          window.location.href = "/login.html";
          return;
        }

        try {
          currentUser = JSON.parse(atob(token.split(".")[1]));

          updateGreeting();
          updateDateTime();

          selectedDate = new Date().toISOString().split("T")[0];
          document.getElementById("filterDate").value = selectedDate;

          await loadStores();
          await loadEmployees();

          // Configurar interface inicial após carregar funcionários
          configureInitialInterface();

          await loadTasks();
          updateStatistics();

          // Configurar atualizações periódicas
          setInterval(async () => {
            await loadTasks();
            updateStatistics();
          }, 60000);

          setupFilterEvents();
        } catch (error) {
          console.error("Erro na inicialização:", error);
          logout();
        }
      }

      function setupFilterEvents() {
        // Filtro de data
        document
          .getElementById("filterDate")
          .addEventListener("change", async (e) => {
            selectedDate = e.target.value;
            await loadTasks();
            await loadEmployees();
            updateStatistics();
          });

        // Filtro de status
        document
          .getElementById("filterStatus")
          .addEventListener("change", async () => {
            await loadTasks();
            updateStatistics();
          });

        // Filtro de loja
        document
          .getElementById("filterStore")
          .addEventListener("change", async () => {
            await loadEmployees();
            await loadTasks();
            updateStatistics();
          });
      }

      async function loadEmployees() {
        try {
          const storeId = document.getElementById("filterStore")?.value;
          let url = `/api/employees/available?date=${selectedDate}`;

          // Se não for admin, usar a loja do usuário atual
          if (!currentUser.isAdmin) {
            // Buscar todos os funcionários para encontrar o usuário atual
            const empResponse = await fetch("/api/employees", {
              headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
              },
            });

            if (!empResponse.ok)
              throw new Error("Erro ao carregar funcionários");
            const allEmployees = await empResponse.json();

            // Encontrar o funcionário atual e sua loja
            const currentEmployee = allEmployees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            if (currentEmployee && currentEmployee.store_id) {
              // Atualizar o select de loja
              const filterStore = document.getElementById("filterStore");
              if (filterStore) {
                filterStore.value = currentEmployee.store_id;
                filterStore.disabled = true;
              }

              url += `&store_id=${currentEmployee.store_id}`;
            }
          } else if (storeId) {
            url += `&store_id=${storeId}`;
          }

          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) throw new Error("Erro ao carregar funcionários");

          employees = await response.json();
          updateEmployeeSelect();
          renderTaskGrid();
        } catch (error) {
          console.error("Erro ao carregar funcionários:", error);
          showNotification("Erro ao carregar funcionários", "error");
        }
      }

      // Adicionar função para atualizar a saudação
      function getCurrentUser() {
        try {
          const token = localStorage.getItem("token");
          if (!token) return null;

          const base64Url = token.split(".")[1];
          const base64 = base64Url.replace(/-/g, "+").replace(/_/g, "/");
          const jsonPayload = decodeURIComponent(
            atob(base64)
              .split("")
              .map(function (c) {
                return "%" + ("00" + c.charCodeAt(0).toString(16)).slice(-2);
              })
              .join("")
          );

          return JSON.parse(jsonPayload);
        } catch (error) {
          console.error("Erro ao decodificar token:", error);
          return null;
        }
      }

      // Adicionar função para configurar interface baseada no usuário
      function configureUserInterface() {
        const adminElements = document.querySelectorAll(".admin-only");
        adminElements.forEach((el) => {
          el.style.display = currentUser.isAdmin ? "block" : "none";
        });
      }
      function updateEmployeesByStore() {
        const storeId = document.getElementById("taskStore").value;
        const assignedTo = document.getElementById("assignedTo");

        assignedTo.innerHTML =
          '<option value="">Distribuição Automática</option>';

        const filteredEmployees = employees.filter(
          (emp) =>
            !emp.on_leave && (!storeId || emp.store_id.toString() === storeId)
        );

        filteredEmployees.forEach((emp) => {
          assignedTo.innerHTML += `
            <option value="${emp.id}">
                ${emp.name} (${emp.task_count || 0} tarefas)
            </option>
        `;
        });
      }
      function checkWorkingStatus() {
        const now = new Date();
        const currentTime =
          now.getHours().toString().padStart(2, "0") +
          ":" +
          now.getMinutes().toString().padStart(2, "0");

        employees.forEach((emp) => {
          emp.is_working =
            currentTime >= emp.work_start &&
            currentTime <= emp.work_end &&
            !emp.on_leave;
        });

        renderTaskGrid();
      }

      // Função principal para atualizar estatísticas
      function updateStatistics() {
        const filteredTasks = tasks;
        const totalTasks = filteredTasks.length;
        const completedTasks = filteredTasks.filter(
          (t) => t.status === "concluido"
        ).length;
        const activeEmployees = employees.filter((e) => !e.on_leave).length;

        document.getElementById("totalTasks").textContent = totalTasks;
        document.getElementById("completedTasks").textContent = completedTasks;
        document.getElementById("activeEmployees").textContent =
          activeEmployees;
      }

      // Modificar a função loadTasks para garantir que as estatísticas sejam atualizadas
      async function loadTasks() {
        try {
          const statusFilter = document.getElementById("filterStatus").value;
          const dateFilter = document.getElementById("filterDate").value;

          // Obter store_id do filtro ou do usuário atual
          let storeId;
          if (!currentUser.isAdmin) {
            // Para não-admin, sempre usar a loja do usuário
            const currentEmployee = employees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            storeId = currentEmployee?.store_id;
          } else {
            // Para admin, usar o filtro de loja selecionado
            storeId = document.getElementById("filterStore")?.value;
          }

          // Construir URL com os filtros
          let url = `/api/tasks?date=${dateFilter}`;

          // Sempre incluir store_id se estiver definido
          if (storeId) {
            url += `&store_id=${storeId}`;
          }

          // Adicionar filtro de status se houver
          if (statusFilter && statusFilter !== "all") {
            url += `&status=${statusFilter}`;
          }

          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) {
            throw new Error("Erro ao carregar tarefas");
          }

          tasks = await response.json();

          renderTaskGrid();
          updateStatistics();
        } catch (error) {
          console.error("Erro ao carregar tarefas:", error);
          showNotification("Erro ao carregar tarefas", "error");
        }
      }

      // Atualizar select de funcionários
      async function updateEmployeeSelect() {
        try {
          const select = document.getElementById("assignedTo");
          select.innerHTML =
            '<option value="">Distribuição Automática</option>';

          // Determinar a loja correta
          let storeId;
          if (currentUser.isAdmin) {
            storeId = document.getElementById("taskStore")?.value;
            if (!storeId) {
              return; // Se admin não selecionou loja, não carregar funcionários
            }
          } else {
            const currentEmployee = employees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            storeId = currentEmployee?.store_id;
          }

          if (!storeId) {
            showNotification("Selecione uma loja primeiro", "warning");
            return;
          }

          const now = new Date();
          const currentTime =
            now.getHours().toString().padStart(2, "0") +
            ":" +
            now.getMinutes().toString().padStart(2, "0");

          // Filtrar funcionários da loja selecionada
          const availableEmployees = employees.filter(
            (emp) =>
              emp.store_id === parseInt(storeId) &&
              !emp.on_leave &&
              currentTime >= emp.work_start &&
              currentTime <= emp.work_end
          );

          availableEmployees.forEach((emp) => {
            select.innerHTML += `
                <option value="${emp.id}">
                    ${emp.name} (${emp.task_count || 0} tarefas)
                </option>
            `;
          });
        } catch (error) {
          console.error("Erro ao atualizar select de funcionários:", error);
          showNotification(
            "Erro ao carregar funcionários disponíveis",
            "error"
          );
        }
      }

      // Renderizar grid de tarefas
      function renderTaskGrid() {
        const grid = document.getElementById("taskGrid");
        grid.innerHTML = "";

        // Obter o filtro de loja atual
        const storeFilter = document.getElementById("filterStore")?.value;

        // Filtrar funcionários pela loja selecionada
        const filteredEmployees = storeFilter
          ? employees.filter((emp) => emp.store_id === parseInt(storeFilter))
          : employees;

        const tasksByEmployee = new Map();
        filteredEmployees.forEach((emp) => {
          tasksByEmployee.set(emp.id, []);
        });

        tasks.forEach((task) => {
          if (task.employee_id && tasksByEmployee.has(task.employee_id)) {
            tasksByEmployee.get(task.employee_id).push(task);
          }
        });

        // Primeiro, renderizar o card do usuário atual se estiver na loja filtrada
        const currentEmployee = filteredEmployees.find(
          (emp) => emp.id === currentUser.employeeId
        );
        if (currentEmployee) {
          const currentUserTasks =
            tasksByEmployee.get(currentUser.employeeId) || [];
          const currentUserCard = createEmployeeCard(
            currentEmployee,
            currentUserTasks,
            true
          );
          grid.appendChild(currentUserCard);
        }

        // Depois, renderizar os cards dos outros funcionários da loja filtrada
        filteredEmployees.forEach((emp) => {
          if (emp.id !== currentUser.employeeId) {
            const employeeTasks = tasksByEmployee.get(emp.id) || [];
            const card = createEmployeeCard(emp, employeeTasks, false);
            grid.appendChild(card);
          }
        });
      }

      function createEmployeeCard(emp, employeeTasks, isCurrentUser) {
    const selectedDate = document.getElementById('filterDate')?.value || new Date().toISOString().split('T')[0];
    
    const card = document.createElement("div");
    card.className = `employee-card ${isCurrentUser ? "current-user" : ""}`;

    if (isCurrentUser) {
        card.style.border = "2px solid var(--accent)";
    }

    const workHours = getEmployeeWorkHours(emp, selectedDate);
    const isWorking = isWithinWorkHours(emp, selectedDate);
    const storeName = stores.find((s) => s.id === emp.store_id)?.name || "Sem loja";

    const weekDays = {
        1: 'Segunda',
        2: 'Terça',
        3: 'Quarta',
        4: 'Quinta',
        5: 'Sexta',
        6: 'Sábado',
        7: 'Domingo'
    };

    const completedTasks = employeeTasks.filter((t) => t.status === "concluido").length;
    const totalTasks = employeeTasks.length;
    const completionRate = totalTasks ? ((completedTasks / totalTasks) * 100).toFixed(0) : 0;

    let statusClass, statusText;
    if (emp.on_leave) {
        statusClass = "status-leave";
        statusText = "De Folga";
    } else if (!isWorking) {
        statusClass = "status-off";
        statusText = "Fora de Expediente";
    } else {
        statusClass = "status-working";
        statusText = "Disponível";
    }

    card.innerHTML = `
        <div class="employee-header">
            <div class="employee-info">
                <div class="employee-name">
                    ${emp.name}
                    ${isCurrentUser ? '<span class="current-user-badge">Você</span>' : ""}
                    <span class="store-badge">${storeName}</span>
                </div>
                <div class="work-schedule">
                    🕒 Horário: ${workHours.start} - ${workHours.end}
                    ${workHours.isAlternative ? 
                        `<span class="alternative-badge">
                            Horário Alternativo (${weekDays[workHours.dayOfWeek]})
                        </span>` 
                        : ''}
                </div>
                <div class="employee-task-count">
                    ${totalTasks} tarefas • ${completionRate}% concluído
                </div>
            </div>
            <span class="employee-status ${statusClass}">
                ${statusText}
            </span>
        </div>
        <div class="tasks-container">
            ${employeeTasks.length === 0 
                ? '<div class="no-tasks">Sem tarefas atribuídas</div>' 
                : employeeTasks.map((task) => {
                    const canEdit = (currentUser.isAdmin || isCurrentUser) && 
                                  isWorking && !emp.on_leave;

                    return `
                        <div class="task-item ${task.is_fixed ? "fixed" : ""} 
                                    ${task.status === "concluido" ? "completed" : ""}">
                            <div class="task-info">
                                <span class="task-priority priority-${task.priority}"></span>
                                <div class="task-name">${task.name}</div>
                            </div>
                            <div class="task-controls">
                                <select class="task-status status-${task.status}"
                                        onchange="updateTaskStatus(${task.id}, this.value)"
                                        ${!canEdit ? "disabled" : ""}>
                                    <option value="pendente" 
                                        ${task.status === "pendente" ? "selected" : ""}>
                                        Pendente
                                    </option>
                                    <option value="em-andamento" 
                                        ${task.status === "em-andamento" ? "selected" : ""}>
                                        Em Andamento
                                    </option>
                                    <option value="concluido" 
                                        ${task.status === "concluido" ? "selected" : ""}>
                                        Concluído
                                    </option>
                                </select>
                                ${
                                    currentUser.isAdmin && !task.is_fixed
                                        ? `<button 
                                            class="btn btn-danger btn-small" 
                                            onclick="deleteTask(${task.id})"
                                            title="Remover Tarefa">×</button>`
                                        : ""
                                }
                            </div>
                        </div>
                    `;
                }).join("")}
        </div>
    `;

    return card;
}

function isValidAlternativeSchedule(schedule) {
    if (!schedule) return false;
    try {
        const parsed = typeof schedule === 'string' ? JSON.parse(schedule) : schedule;
        return Object.entries(parsed).every(([day, times]) => {
            return (
                day >= 1 && day <= 7 &&
                times.work_start &&
                times.work_end &&
                typeof times.work_start === 'string' &&
                typeof times.work_end === 'string' &&
                /^\d{2}:\d{2}$/.test(times.work_start) &&
                /^\d{2}:\d{2}$/.test(times.work_end)
            );
        });
    } catch (error) {
        console.error('Erro na validação do horário alternativo:', error);
        return false;
    }
}

function getEmployeeWorkHours(emp, selectedDate = null) {
    try {
        // Criar a data no fuso horário local para evitar problemas com UTC
        const date = selectedDate ? new Date(`${selectedDate}T00:00:00`) : new Date();
        let currentDay = date.getDay(); // 0-6 (0 = Domingo)
        currentDay = currentDay === 0 ? 7 : currentDay; // Converte Domingo de 0 para 7
      

        if (emp.alternative_schedule) {
            const altSchedule = typeof emp.alternative_schedule === 'string' 
                ? JSON.parse(emp.alternative_schedule) 
                : emp.alternative_schedule;

            if (altSchedule[currentDay]) {
                
                return {
                    start: altSchedule[currentDay].work_start,
                    end: altSchedule[currentDay].work_end,
                    isAlternative: true,
                    dayOfWeek: currentDay
                };
            }
        }
        
        return {
            start: emp.work_start,
            end: emp.work_end,
            isAlternative: false,
            dayOfWeek: currentDay
        };
    } catch (error) {
        console.error('Erro ao processar horário alternativo:', error);
        return {
            start: emp.work_start,
            end: emp.work_end,
            isAlternative: false,
            dayOfWeek: currentDay
        };
    }
}

// Modifique a função isWithinWorkHours existente para usar getEmployeeWorkHours
function isWithinWorkHours(emp, selectedDate = null) {
    try {
        const workHours = getEmployeeWorkHours(emp, selectedDate);
        const now = new Date();
        const currentTime = now.getHours().toString().padStart(2, "0") + ":" + 
                          now.getMinutes().toString().padStart(2, "0");

        return currentTime >= workHours.start && currentTime <= workHours.end;
    } catch (error) {
        console.error('Erro ao verificar horário de trabalho:', error);
        return false;
    }
}


      // Atualizar status da tarefa
      async function updateTaskStatus(taskId, status) {
        try {
          const response = await fetch(`/api/tasks/${taskId}/status`, {
            method: "PATCH",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              status,
              date: document.getElementById("filterDate").value,
            }),
          });

          if (!response.ok) {
            const error = await response.json();
            throw new Error(error.message || "Erro ao atualizar status");
          }

          // Atualizar a tarefa localmente
          const taskIndex = tasks.findIndex((t) => t.id === taskId);
          if (taskIndex !== -1) {
            tasks[taskIndex].status = status;
            updateStatistics(); // Atualizar estatísticas imediatamente
          }

          await loadTasks(); // Recarregar todas as tarefas
          showNotification("Status atualizado com sucesso", "success");
        } catch (error) {
          console.error("Erro ao atualizar status:", error);
          showNotification(error.message, "error");
        }
      }

      async function getFixedTasksHistory(startDate, endDate) {
        try {
          const response = await fetch(
            `/api/tasks/fixed/history?start=${startDate}&end=${endDate}`,
            {
              headers: {
                Authorization: `Bearer ${localStorage.getItem("token")}`,
              },
            }
          );

          if (!response.ok) throw new Error("Erro ao buscar histórico");
          return await response.json();
        } catch (error) {
          console.error("Erro ao buscar histórico:", error);
          return [];
        }
      }

      // Distribuir tarefas automaticamente
      async function distributeTasksAutomatically() {
        try {
          let storeId;

          if (currentUser.isAdmin) {
            const selectedStore = await showStoreSelectionModal();
            if (!selectedStore) return;
            storeId = selectedStore;
          } else {
            const currentEmployee = employees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            storeId = currentEmployee?.store_id;
          }

          if (!storeId) {
            showNotification("Erro: Loja não definida", "error");
            return;
          }

          // Verificar tarefas não atribuídas antes da distribuição
          const unassignedTasks = tasks.filter(
            (task) =>
              task.store_id === parseInt(storeId) &&
              (!task.employee_id || task.employee_id === 0) &&
              task.date === selectedDate
          );

          const response = await fetch("/api/tasks/distribute", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify({
              store_id: storeId,
              date: selectedDate,
              debug: {
                unassignedTaskCount: unassignedTasks.length,
                totalTaskCount: tasks.length,
                currentDate: new Date().toISOString(),
              },
            }),
          });

          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.message);
          }

          await loadTasks();
          await loadEmployees();
          updateStatistics();
          showNotification(result.message, "success");
        } catch (error) {
          console.error("Erro ao distribuir tarefas:", error);
          showNotification(error.message, "error");
        }
      }

      function showStoreSelectionModal() {
        return new Promise((resolve) => {
          // Criar modal dinamicamente
          const modalHtml = `
            <div id="storeSelectionModal" class="modal">
                <div class="modal-content">
                    <div class="modal-header">
                        <h2>Selecionar Loja</h2>
                    </div>
                    <div class="form-group">
                        <label for="distributeStore">Selecione a loja para distribuir as tarefas:</label>
                        <select id="distributeStore" class="form-control">
                            <option value="">Selecione uma loja</option>
                            ${stores
                              .filter((store) => store.active)
                              .map(
                                (store) => `
                                    <option value="${store.id}">${store.name}</option>
                                `
                              )
                              .join("")}
                        </select>
                    </div>
                    <div class="modal-footer">
                        <button class="btn btn-danger" onclick="closeStoreSelectionModal(null)">Cancelar</button>
                        <button class="btn btn-success" onclick="confirmStoreSelection()">Confirmar</button>
                    </div>
                </div>
            </div>
        `;

          // Adicionar modal ao body
          const modalContainer = document.createElement("div");
          modalContainer.innerHTML = modalHtml;
          document.body.appendChild(modalContainer);

          const modal = document.getElementById("storeSelectionModal");
          modal.style.display = "block";

          // Adicionar funções de fechamento do modal ao escopo global
          window.closeStoreSelectionModal = (storeId) => {
            modal.remove();
            resolve(storeId);
          };

          window.confirmStoreSelection = () => {
            const selectedStore =
              document.getElementById("distributeStore").value;
            if (!selectedStore) {
              showNotification("Selecione uma loja", "warning");
              return;
            }
            closeStoreSelectionModal(selectedStore);
          };

          // Fechar modal ao clicar fora
          modal.onclick = (e) => {
            if (e.target === modal) {
              closeStoreSelectionModal(null);
            }
          };
        });
      }

      // Salvar nova tarefa
      async function saveTask() {
        const name = document.getElementById("taskName").value;
        const description = document.getElementById("taskDescription").value;
        const employeeId = document.getElementById("assignedTo").value;
        const priority = document.getElementById("taskPriority").value;
        const isFixed = document.getElementById("isFixed").checked;

        if (!name) {
          showNotification("Digite o nome da tarefa", "warning");
          return;
        }

        // Determinar a loja correta
        let storeId;
        if (currentUser.isAdmin) {
          storeId = document.getElementById("taskStore")?.value;
          if (!storeId) {
            showNotification("Selecione uma loja", "warning");
            return;
          }
        } else {
          const currentEmployee = employees.find(
            (emp) => emp.id === currentUser.employeeId
          );
          storeId = currentEmployee?.store_id;
        }

        if (!storeId) {
          showNotification("Erro: Loja não definida", "error");
          return;
        }

        try {
          const taskData = {
            name,
            description,
            employeeId: employeeId || null,
            priority: parseInt(priority),
            isFixed,
            date: selectedDate,
            store_id: parseInt(storeId),
          };

          const response = await fetch("/api/tasks", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
            body: JSON.stringify(taskData),
          });

          const result = await response.json();

          if (!response.ok) {
            throw new Error(result.message || "Erro ao criar tarefa");
          }

          // Adicionar a nova tarefa ao array local
          const newTask = {
            ...result,
            store_id: parseInt(storeId),
          };
          tasks.push(newTask);

          // Atualizar estatísticas e interface
          updateStatistics();
          renderTaskGrid();

          closeTaskModal();

          // Recarregar dados
          await Promise.all([loadTasks(), loadEmployees()]);

          showNotification("Tarefa criada com sucesso", "success");
        } catch (error) {
          console.error("Erro ao salvar tarefa:", error);
          showNotification(error.message, "error");
        }
      }

      // Excluir tarefa
      async function deleteTask(taskId) {
        try {
          const task = tasks.find((t) => t.id === taskId);
          if (!task) throw new Error("Tarefa não encontrada");

          const canDelete =
            currentUser.isAdmin || task.employee_id === currentUser.employeeId;

          if (!canDelete) {
            throw new Error("Você não tem permissão para excluir esta tarefa");
          }

          if (!confirm("Tem certeza que deseja excluir esta tarefa?")) return;

          const response = await fetch(`/api/tasks/${taskId}`, {
            method: "DELETE",
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) throw new Error("Erro ao excluir tarefa");

          // Remover a tarefa localmente
          tasks = tasks.filter((t) => t.id !== taskId);
          updateStatistics(); // Atualizar estatísticas imediatamente

          await loadTasks(); // Recarregar todas as tarefas
          showNotification("Tarefa excluída com sucesso", "success");
        } catch (error) {
          console.error("Erro ao excluir tarefa:", error);
          showNotification(error.message, "error");
        }
      }

      // Atualizar estatísticas
      // Função atualizada para carregar tarefas
      async function loadTasks() {
        try {
          const statusFilter = document.getElementById("filterStatus").value;
          const dateFilter = document.getElementById("filterDate").value;

          // Obter store_id do filtro ou do usuário atual
          let storeId;
          if (!currentUser.isAdmin) {
            // Para não-admin, sempre usar a loja do usuário
            const currentEmployee = employees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            storeId = currentEmployee?.store_id;
          } else {
            // Para admin, usar o filtro de loja selecionado
            storeId = document.getElementById("filterStore")?.value;
          }

          // Construir URL com os filtros
          let url = `/api/tasks?date=${dateFilter}`;

          // Sempre incluir store_id se estiver definido
          if (storeId) {
            url += `&store_id=${storeId}`;
          }

          // Adicionar filtro de status se houver
          if (statusFilter && statusFilter !== "all") {
            url += `&status=${statusFilter}`;
          }

          const response = await fetch(url, {
            headers: {
              Authorization: `Bearer ${localStorage.getItem("token")}`,
            },
          });

          if (!response.ok) {
            throw new Error("Erro ao carregar tarefas");
          }

          tasks = await response.json();

          renderTaskGrid();
          updateStatistics();
        } catch (error) {
          console.error("Erro ao carregar tarefas:", error);
          showNotification("Erro ao carregar tarefas", "error");
        }
      }

      // Atualizar também a função updateStatistics para considerar apenas tarefas da loja
      function updateStatistics() {
        try {
          // Filtrar tarefas pela loja atual
          let storeId;
          if (!currentUser.isAdmin) {
            const currentEmployee = employees.find(
              (emp) => emp.id === currentUser.employeeId
            );
            storeId = currentEmployee?.store_id;
          } else {
            storeId = document.getElementById("filterStore")?.value;
          }

          // Filtrar tarefas pela loja se houver store_id
          const filteredTasks = storeId
            ? tasks.filter((task) => task.store_id === parseInt(storeId))
            : tasks;

          // Calcular estatísticas apenas com as tarefas filtradas
          const totalTasks = filteredTasks.length;
          const completedTasks = filteredTasks.filter(
            (t) => t.status === "concluido"
          ).length;

          // Filtrar funcionários ativos da loja
          const activeEmployees = employees.filter((emp) => {
            return (
              (!storeId || emp.store_id === parseInt(storeId)) && !emp.on_leave
            );
          }).length;

          // Atualizar elementos na interface
          document.getElementById("totalTasks").textContent = totalTasks;
          document.getElementById("completedTasks").textContent =
            completedTasks;
          document.getElementById("activeEmployees").textContent =
            activeEmployees;
        } catch (error) {
          console.error("Erro ao atualizar estatísticas:", error);
        }
      }

      function closeTaskModal() {
        const modal = document.getElementById("taskModal");
        modal.style.display = "none";

        // Limpar todos os campos
        document.getElementById("taskName").value = "";
        document.getElementById("taskDescription").value = "";
        document.getElementById("taskPriority").value = "1";
        document.getElementById("assignedTo").innerHTML =
          '<option value="">Distribuição Automática</option>';
        document.getElementById("isFixed").checked = false;

        // Limpar select de loja se for admin
        if (currentUser.isAdmin && document.getElementById("taskStore")) {
          document.getElementById("taskStore").value = "";
        }
      }

      // Sistema de notificações
      function showNotification(message, type = "info") {
        const notification = document.getElementById("notification");

        // Remover classes anteriores
        notification.className = "notification";

        // Adicionar classe do tipo
        notification.classList.add(type);

        // Definir mensagem
        notification.textContent = message;

        // Mostrar notificação
        notification.style.display = "block";
        notification.style.animation = "slideIn 0.3s ease";

        // Configurar temporizador para remover
        const timeout = type === "error" ? 5000 : 3000; // Erros ficam visíveis por mais tempo

        setTimeout(() => {
          // Animação de saída
          notification.style.animation = "slideOut 0.3s ease";

          // Remover após animação
          setTimeout(() => {
            notification.style.display = "none";
          }, 290);
        }, timeout);
      }

      // Função para tratar erros de requisições
      async function handleApiError(response) {
        if (!response.ok) {
          const data = await response.json();
          throw new Error(data.message || "Erro na operação");
        }
        return response;
      }

      // Event Listeners
      document.getElementById("filterDate").addEventListener("change", (e) => {
        selectedDate = e.target.value;
        loadEmployees();
        loadTasks();
      });

      document.getElementById("filterStatus").addEventListener("change", () => {
        loadTasks();
      });

      // Fechar modal ao clicar fora
      window.addEventListener("click", (e) => {
        const modal = document.getElementById("taskModal");
        if (e.target === modal) {
          closeTaskModal();
        }
      });

      // Inicializar aplicação
      init();
    </script>
    <div id="notification" class="notification"></div>
  </body>
</html>
